## **Домашнее задание к занятию "Использование Python для решения типовых DevOps задач"**
### **Цель задания**
В результате выполнения этого задания вы:

1. Познакомитесь с синтаксисом Python.
2. Узнаете, для каких типов задач его можно использовать.
3. Воспользуетесь несколькими модулями для работы с ОС.
### **Инструкция к заданию**
1. Установите Python 3 любой версии.
2. Скопируйте в свой .md-файл содержимое этого файла; исходники можно посмотреть здесь.
3. Заполните недостающие части документа решением задач (заменяйте ???, остальное в шаблоне не меняйте, чтобы не сломать форматирование текста, подсветку синтаксиса). Вместо логов можно вставить скриншоты по желанию.
4. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
5. Любые вопросы по выполнению заданий спрашивайте в чате учебной группы и/или в разделе “Вопросы по заданию” в личном кабинете.
### **Дополнительные материалы**
[Полезные ссылки для модуля "Скриптовые языки и языки разметки"](https://github.com/netology-code/sysadm-homeworks/tree/devsys10/04-script-03-yaml/additional-info)

### **Задание 1**
Есть скрипт:
```
#!/usr/bin/env python3
a = 1
b = '2'
c = a + b
```
### **Вопросы:**
```
Вопрос	                                            Ответ
Какое значение будет присвоено переменной c?	    TypeError: unsupported operand type(s) for +: 'int' and 'str'
Как получить для переменной c значение 12?	    c = str(a) + b
Как получить для переменной c значение 3?	    c = a + int(b)
```
### **Задание 2**
Мы устроились на работу в компанию, где раньше уже был DevOps Engineer. Он написал скрипт, позволяющий узнать, какие файлы модифицированы в репозитории, относительно локальных изменений. Этим скриптом недовольно начальство, потому что в его выводе есть не все изменённые файлы, а также непонятен полный путь к директории, где они находятся.

Как можно доработать скрипт ниже, чтобы он исполнял требования вашего руководителя?
```
#!/usr/bin/env python3

import os

bash_command = ["cd ~/netology/sysadm-homeworks", "git status"]
result_os = os.popen(' && '.join(bash_command)).read()
is_change = False
for result in result_os.split('\n'):
    if result.find('modified') != -1:
        prepare_result = result.replace('\tmodified:   ', '')
        print(prepare_result)
        break
```        
### **Ваш скрипт:**
```
import os
from pprint import pprint

bash_command = ["cd /home/nevermind/PycharmProjects/pythonProject/devops-netology", "git status"]
result_os = os.popen(' && '.join(bash_command)).read()
is_change = False
for result in result_os.split('\n'):
    if result.find('изменено:') !=-1:
        prepare_result = result.replace('\tизменено:   ', '')
        abs_path = os.path.abspath(prepare_result)
        pprint(abs_path)
        break
```
### **Вывод скрипта при запуске при тестировании:**
```
('/home/nevermind/PycharmProjects/pythonProject/devops-netology/DevOps  and '
 'system administration/3 Scripting and markup languages: Python, Bash, YAML, '
 'JSON/2 Python/   DevOps  and system administration/3 Scripting and markup '
 'languages: Python, Bash, YAML, JSON/2 Python/README.md')
```
### **Задание 3**
Доработать скрипт выше так, чтобы он не только мог проверять локальный репозиторий в текущей директории, но и умел воспринимать путь к репозиторию, который мы передаём как входной параметр. Мы точно знаем, что начальство коварное и будет проверять работу этого скрипта в директориях, которые не являются локальными репозиториями.

### **Ваш скрипт:**
```
import os
from pprint import pprint

input_path = input('Введите путь до локальной директории \n')
bash_command = ["cd " + input_path, 'git status']
result_os = os.popen(' && '.join(bash_command)).read()
is_change = False
for result in result_os.split('\n'):
    if result.find('изменено:') !=-1:
        prepare_result = result.replace('\tизменено:   ', '')
        abs_path = os.path.abspath(prepare_result)
        pprint(abs_path)
        break
```
### **Вывод скрипта при запуске при тестировании:**
```
('/home/nevermind/PycharmProjects/pythonProject/devops-netology/DevOps  and '
 'system administration/3 Scripting and markup languages: Python, Bash, YAML, '
 'JSON/2 Python/   DevOps  and system administration/3 Scripting and markup '
 'languages: Python, Bash, YAML, JSON/2 Python/README.md')
```
### **Задание 4**
Наша команда разрабатывает несколько веб-сервисов, доступных по http. Мы точно знаем, что на их стенде нет никакой балансировки, кластеризации, за DNS прячется конкретный IP сервера, где установлен сервис.

Проблема в том, что отдел, занимающийся нашей инфраструктурой очень часто меняет нам сервера, поэтому IP меняются примерно раз в неделю, при этом сервисы сохраняют за собой DNS имена. Это бы совсем никого не беспокоило, если бы несколько раз сервера не уезжали в такой сегмент сети нашей компании, который недоступен для разработчиков.

Мы хотим написать скрипт, который:

* опрашивает веб-сервисы,
* получает их IP,
* выводит информацию в стандартный вывод в виде: <URL сервиса> - <его IP>.
Также, должна быть реализована возможность проверки текущего IP сервиса c его IP из предыдущей проверки. Если проверка будет провалена - оповестить об этом в стандартный вывод сообщением: [ERROR] <URL сервиса> IP mismatch: <старый IP> <Новый IP>. Будем считать, что наша разработка реализовала сервисы: drive.google.com, mail.google.com, google.com.

### **Ваш скрипт:**
Вариант 1
```
#!/usr/bin/env python3

import os
from pprint import pprint
import socket

url = {'drive.google.com' : '142.251.31.194', 'mail.google.com': '142.251.143.37', 'google.com': '142.250.180.110'}

class Ping_url():
    def __init__(self, url):
        self.url = url
    new_url = {}
    for k, v in url.items():
        apdt_url = socket.gethostbyname(k)
        pprint(f'URL сервиса {k}, IP сервиса {apdt_url}')
    for key, value in url.items():
        socket_url = socket.gethostbyname(key)
        if value == socket_url:
            pprint(f'URL сервиса {key} его ip {value}')
        else:
            pprint(f'[ERROR] URL сервиса {key} IP mismatch: старый IP - {value} Новый IP - {socket_url}')
            url[key] = socket_url

Ping_url(url)
```
Вариант 2
```
#!/usr/bin/env python3

#import os
import socket
#import sys
#import subprocess

hostnames = {'drive.google.com': '64.233.164.194', 'mail.google.com': '64.233.165.19', 'google.com': '64.233.165.113'}

for hostname, value in hostnames.items():
#    print(hostname)
    try:
        ip = socket.gethostbyname(hostname)
        #print(f'The {hostname} IP Address is {ip}')
        if value == ip:
            print(f'{hostname}: IP {value} в словаре и последний полученный {ip} СОВПАДАЮТ, все ок не трогаем')
        else:
            print(f'{hostname}:  IP {value} в словаре и последний полученный {ip} НЕ_СОВПАДАЮТ, надо апдейтить')
            hostnames[hostname] = ip
    except socket.gaierror as e:
        hostnames[hostname] = None
        print(f'[ERROR] {hostname} >> Не резолвится {e}')
print(f'DICT update >>> {hostnames}')

```
### **Вывод скрипта при запуске при тестировании:**
```
'URL сервиса drive.google.com, IP сервиса 142.251.31.194'
'URL сервиса mail.google.com, IP сервиса 142.251.143.37'
'URL сервиса google.com, IP сервиса 142.250.180.110'
'URL сервиса drive.google.com его ip 142.251.31.194'
'URL сервиса mail.google.com его ip 142.251.143.37'
'URL сервиса google.com его ip 142.250.180.110'

Process finished with exit code 0

```
### **Дополнительное задание (со звездочкой) - необязательно к выполнению**
Так получилось, что мы очень часто вносим правки в конфигурацию своей системы прямо на сервере. Но так как вся наша команда разработки держит файлы конфигурации в github и пользуется gitflow, то нам приходится каждый раз:

* переносить архив с нашими изменениями с сервера на наш локальный компьютер,
* формировать новую ветку,
* коммитить в неё изменения,
* создавать pull request (PR)
* и только после выполнения Merge мы наконец можем официально подтвердить, что новая конфигурация применена.
Мы хотим максимально автоматизировать всю цепочку действий.

* Для этого нам нужно написать скрипт, который будет в директории с локальным репозиторием обращаться по API к github, создавать PR для вливания текущей выбранной ветки в master с сообщением, которое мы вписываем в первый параметр при обращении к py-файлу (сообщение не может быть пустым).
* При желании, можно добавить к указанному функционалу создание новой ветки, commit и push в неё изменений конфигурации.
* С директорией локального репозитория можно делать всё, что угодно.
* Также, принимаем во внимание, что Merge Conflict у нас отсутствуют и их точно не будет при push, как в свою ветку, так и при слиянии в master.
Важно получить конечный результат с созданным PR, в котором применяются наши изменения.

### **Ваш скрипт:**
    ???
### **Вывод скрипта при запуске при тестировании:**
    ???
### **Правила приема домашнего задания**
В личном кабинете отправлена ссылка на .md файл в вашем репозитории.

### **Критерии оценки**
Зачет - выполнены все задания, ответы даны в развернутой форме, приложены соответствующие скриншоты и файлы проекта, в выполненных заданиях нет противоречий и нарушения логики.

На доработку - задание выполнено частично или не выполнено, в логике выполнения заданий есть противоречия, существенные недостатки.

Обязательными к выполнению являются задачи без указания звездочки. Их выполнение необходимо для получения зачета и диплома о профессиональной переподготовке. Задачи со звездочкой (*) являются дополнительными задачами и/или задачами повышенной сложности. Они не являются обязательными к выполнению, но помогут вам глубже понять тему.