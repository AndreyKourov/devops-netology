## **Домашнее задание к занятию "5.3. Контейнеризация на примере Docker"**
### **Задача 1**
Посмотрите на сценарий ниже и ответьте на вопрос: "Подходит ли в этом сценарии использование докера? Или лучше подойдет виртуальная машина, физическая машина? Или возможны разные варианты?"

Детально опишите и обоснуйте свой выбор.

--

Сценарий:

* Высоконагруженное монолитное java веб-приложение; 
* Go-микросервис для генерации отчетов;
* Nodejs веб-приложение;
* Мобильное приложение c версиями для Android и iOS;
* База данных postgresql используемая, как кэш;
* Шина данных на базе Apache Kafka;
* Очередь для Logstash на базе Redis;
* Elastic stack для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
* Мониторинг-стек на базе prometheus и grafana;
* Mongodb, как основное хранилище данных для java-приложения;
* Jenkins-сервер.
#### **Ответы**
* Высоконагруженное монолитное java веб-приложение  >>>>>  видимо тут ключевое слово "монолитное". Для меня это самостоятельное приложение, не требующее какой то доп связки. Что то вроде джарника/варника с конфигом. Если так, то докер тут не нужен.
* Go-микросервис для генерации отчетов  >>>>>  в принципе микросервисом можно назвать под, т.к. каждый под у нас выполняет какую то свою роль в изолированной среде. Тут если у нас микросервисов много и мы хотим все эти отчеты выводить в UI... ну в принципе можно контейнеризацию применить.  В общем тут от кол-ва сервисов зависит и от настроения саппорта :)
* Nodejs веб-приложение  >>>>>  большинство статей описывают настройку nodejs-приложения с помощью докера. Думаю это все из-за удобства поставки обновлений, дебага, тестирования и управления.
* Мобильное приложение c версиями для Android и iOS  >>>>>  тут докер тоже будет неплохим решением, т.к. оси абсолютно разные и изолировать их друг от друга было бы не то чтобы неплохо, было бы супер. Нашли баг а приложении ios, пересобрали контейнер, не затронув андройд + В других контейнерах может крутится, например интеграция, к которой оба контейнера будут обращаться. А тут изоляция маст хев.
* База данных postgresql используемая, как кэш  >>>>>  для кэша есть редис, докер тут не нужен. Для БД тоже докер сомнительное решение.
* Шина данных на базе Apache Kafka  >>>>>  интеграция важная штука, я бы все на железном оборудовании настроил и все серваки в кластер объединил. Докер бы не ставил.
* Очередь для Logstash на базе Redis  >>>>>  тут я бы докер не применял. Сложности настройки, с монтированием папки может проблема возникнуть в которой будет хранится инфа, и которую мы можем потерять при пересоздании контейнера.
* Elastic stack для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana  >>>>>  однозначно докер, да еще и с кубером, и чтоб все были мастерами. Все будет работать пока кластер не сдохнет :)
* Мониторинг-стек на базе prometheus и grafana  >>>>>  Система не критичная. Я бы не использовал докер, просто поднял демона и все.
* Mongodb, как основное хранилище данных для java-приложения  >>>>>  у меня лично монго крутится в докере на виртуалке. За все время ни разу не побеспокоила, а значит это отличное решение)
* Jenkins-сервер  >>>>>  судя по гайду инстала https://www.jenkins.io/doc/book/installing/  докер нигде не упоминается. Но все мои знакомые разрабы дженкинс в докере разворачивают)  Думаю это все из-за удобства поставок новых версий.

### **Задача 2** 
Сценарий выполения задачи:

* создайте свой репозиторий на докерхаб;
* выберете любой образ, который содержит апачи веб-сервер;
* создайте свой форк образа;
* реализуйте функциональность: запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m kinda DevOps now</h1>
</body>
</html>
```
Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на докерхаб-репо.

#### **Решение**
1 Создаем докер фаил (я назвал example_dockerfile ) и прописываем ниже
```
FROM nginx
RUN echo "<html>\n<head>\nHey, Netology\n</head>\n<body>\n<h1>I'm DevOps Engineer!</h1>\n</body>\n</html>" > /usr/share/nginx/html/index.html
EXPOSE 80
```
2 Выполняю комманду что бы скачать нужный image
```
docker pull nginx
или можно
docker run nginx
```
3 Создаем свой image с названием nginx_hw (ключ -t это для указания тэга) из докерфаила example_dockerfile (ключ -f для указазния названия файла) Точка . указывает что файил находится в текущей директории
```
docker build -t nginx_hw -f example_dockerfile .
```
4 Запускаем наш докер контейнер
* Ключ -it интерктивный режим (можно было добавить d что фоновом режиме можно было запускать)
* Ключ --name для того что бы задать имя например nginx_hw1
* Ключ -p открывает порты. Ранее в докере указали 80 порт, а тут мы указали что будем использовать порт 8080
* nginx_hw - конце указывает, что мы используем image nginx_hw
```
docker run -it --name nginx_hw1 -p 8080:80 nginx_hw
```
5 Для отправки созданного iamge сначала необходимо привязать локальный image к своему репозиторию. Где nginx_hw тег локального image, а dockerhubandrey/nginx_hw:1 название_реозитория/название_image:его_тэг 
```
docker tag nginx_hw dockerhubandrey/nginx_hw:1
```
6 Отправляем в репозиторий dockerhubandrey
```
docker push dockerhubandrey/nginx_hw:1
```
### **Задача 3**
* Запустите первый контейнер из образа centos c любым тэгом в фоновом режиме, подключив папку info из текущей рабочей директории на хостовой машине в /share/info контейнера;
* Запустите второй контейнер из образа debian:latest в фоновом режиме, подключив папку info из текущей рабочей директории на хостовой машине в /info контейнера;
* Подключитесь к первому контейнеру с помощью exec и создайте текстовый файл любого содержания в /share/info ;
* Добавьте еще один файл в папку info на хостовой машине;
* Подключитесь во второй контейнер и отобразите листинг и содержание файлов в /info контейнера.

#### **Решение**
1 Скачиваем образы
```
docker pull ubuntu
docker pull centos
```
2 Создаем тестовую директорию info (в домашней директории)
```
sudo mkdir ~/info
```
3 Запустите первый контейнер из образа centos c любым тэгом в фоновом режиме, подключив папку info из текущей рабочей директории на хостовой машине в /share/info контейнера
```
docker run -v ~/info:/share/info -itd --name centos_hw centos
```
4 Запустите второй контейнер из образа debian в фоновом режиме, подключив папку info из текущей рабочей директории на хостовой машине в /info контейнера
```
docker run -v ~/info:/info -itd --name debian_hw debian
```
5 Подключитесь к первому контейнеру с помощью exec и создайте текстовый файл любого содержания в /share/info 
```
docker exec -ti centos_hw /bin/bash
cd share/info
touch file_centos
echo 'file centos' > file_centos
```
6 Добавьте еще один файл в папку info на хостовой машине;
```
cd ~/info
touch file_local
echo 'file local' > file_centos
```
7 Подключитесь во второй контейнер и отобразите листинг и содержание файлов в /info контейнера.
```
docker exec -ti debian_hw /bin/bash
cd /info
ls -la
cat file_centos
cat file_local
```
